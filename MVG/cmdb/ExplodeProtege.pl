=head1 NAME

ExplodeProtege - Explode attribute information generated from a Protege Database table.

=head1 VERSION HISTORY

version 1.0 20 May 2008 DV

=over 4

=item *

Initial release.

=back

=head1 DESCRIPTION

This application will read an class/attribute table as generated by Protege, and will add all inherited attributes to subclasses. Attributes for which the documentation was modified are available already at the subclass and should not be overwritten.

First an array will be prepared that contains all classes, in strict parent-child relationship. This means that in the array a child must be listed after it's parent. At the same time, a parent-child hash will be written, which will be required later on, and does not need to be collected again at that time.

Then each class from the array will be read, it's parent collected, and all it's parent attributes will be read. Each attribute will be added to the child, unless it is already available as a class attribute.

Since the array guarantees the parent-child order for all classes, we're sure that the classes are handled top-down. End of application, each class must have all its attributes.

This script assumes that the table protexplodedattributes is a copy (inclusive data) from the table protegetableattributes.

=head1 SYNOPSIS

 ExplodeProtege.pl [-t] [-l log_dir]

 ExplodeProtege -h	 	   Usage
 ExplodeProtege -h 1	   Usage and description of the options
 ExplodeProtege -h 2	   All documentation

=head1 OPTIONS

=over 4

=item B<-t>

Tracing enabled, default: no tracing

=item B<-l logfile_directory>

default: d:\temp\log

=back

=head1 SUPPORTED PLATFORMS

The script has been developed and tested on Windows 2000, Perl v5.8.0, build 804 provided by ActiveState.

The script should run unchanged on UNIX platforms as well, on condition that all directory settings are provided as input parameters (-l, -p, -c, -d options).

=head1 ADDITIONAL DOCUMENTATION

=cut

###########
# Variables
########### 

my ($logdir,$dbh, $dbh2, @classes, %parent);
my $server="localhost";
my $username="root";
my $password="Monitor1";
my $printerror=0;
my $cmdbmetaDB = "cmdbmeta";
my $table = "protexplodedattributes";
my $table_count = 0;
my $attribute_count = 0;

#####
# use
#####

use warnings;			    # show warning messages
use strict 'vars';
use strict 'refs';
use strict 'subs';
use Getopt::Std;		    # Handle input params
use Pod::Usage;			    # Allow Usage information
use DBI();
use Log;

#############
# subroutines
#############

sub exit_application($) {
    my ($return_code) = @_;
	if (defined $dbh) {
		$dbh->disconnect;
	}
	if (defined $dbh2) {
		$dbh->disconnect;
	}
	my $status_msg = "$table_count table records, $attribute_count attribute records";
	print $status_msg."\n";
	logging($status_msg);
	logging("Exit application with return code $return_code.\n");
    close_log();
    exit $return_code;
}

sub trim {
    my @out = @_;
    for (@out) {
        s/^\s+//;
        s/\s+$//;
    }
    return wantarray ? @out : $out[0];
}

=pod

=head2 Prepare Structure

The Prepare Structure procedure will create the classes array, that lists all classes in strict parent-child relationship. It will maintain parent-child relationship hash at the same time.

The procedure will be called recursively, so be careful with database handles.

=cut

sub prepare_struct($);

sub prepare_struct($) {
	my ($class) = @_;
	my (@tempclasses);
	# NOT query required to avoid Initial thing - thing record
	my $query = "SELECT tablename FROM protegetableinfo 
				 WHERE parent = '$class' AND NOT (tablename = '$class')";
	my $sth = $dbh->prepare($query);
	$sth->execute();
	while (my $ref = $sth->fetchrow_hashref()) {
		my $child = $ref->{tablename};
		push @classes, $child;
		$parent{$child} = $class;
		# All children from a class are stored in tempclasses array
		push @tempclasses, $child;
	}
	# Now handle all discovered children recursively
	foreach my $child (@tempclasses) {
		prepare_struct($child);
	}
}

=pod

=head2 Explode Procedure

The Explode procedure will accept a class/parent pair, find all attributes from the parent and add this attributes to the class, unless the attribute is available already.

=cut

sub explode($$) {
	my ($class, $parent) = @_;
	my $query = "SELECT attribute, documentation, destination 
				 FROM $table WHERE tablename = '$parent'";
	my $sth2 = $dbh2->prepare($query);
	$sth2->execute();
	while (my $ref2 = $sth2->fetchrow_hashref()) {
		my $attribute = $ref2->{attribute};
		my $documentation = $ref2->{documentation};
		my $destination = $ref2->{destination};
		# Check if attribute exists already for this class
		$query = "SELECT attribute FROM $table WHERE tablename = '$class' AND attribute = '$attribute'";
		my $sth = $dbh->prepare($query);
		$sth->execute();
		if (not (my $ref = $sth->fetchrow_hashref())) {
			# Attribute not yet assigned to this class, add it
			write_attribute_info($class, $attribute, $documentation, $destination);
		}
	}
}

=pod

=head2 Write Attribute Info

This procedure will write Protege attribute information into the cmdb metadata database.

=cut

sub write_attribute_info {
	my ($class, $attribute, $documentation, $instance_dest) = @_;
	my $sql = sprintf "INSERT INTO $table (tablename, attribute, documentation, destination)
				values ('$class', '$attribute', %s, '$instance_dest')", $dbh->quote($documentation);
	my $rows_affected = $dbh->do($sql);
	if (not defined $rows_affected) {
		error("PID: $$ - SQL Error with *** $sql");
	}
	$attribute_count++;
}

######
# Main
######

# Handle input values
my %options;
getopts("tl:h:", \%options) or pod2usage(-verbose => 0);
# This application does not require arguments
# my $arglength = scalar keys %options;  
# if ($arglength == 0) {			# If no options specified,
#    $options{"h"} = 0;			# display usage.
# }
# Print Usage
if (defined $options{"h"}) {
    if ($options{"h"} == 0) {
        pod2usage(-verbose => 0);
    } elsif ($options{"h"} == 1) {
        pod2usage(-verbose => 1);
    } else {
	pod2usage(-verbose => 2);
    }
}
# Trace required?
if (defined $options{"t"}) {
    Log::trace_flag(1);
    trace("Trace enabled");
}
# Find log file directory
if ($options{"l"}) {
    $logdir = logdir($options{"l"});
    if (not(defined $logdir)) {
		error("Could not set $logdir as Log directory, exiting...");
		exit_application(1);
    }
} else {
    $logdir = logdir();
    if (not(defined $logdir)) {
		error("Could not find default Log directory, exiting...");
		exit_application(1);
    }
}
if (-d $logdir) {
    trace("Logdir: $logdir");
} else {
    pod2usage(-msg     => "Cannot find log directory $logdir",
	      -verbose => 0);
}
# Logdir found, start logging
open_log();
logging("Start application");
# Show input parameters
while (my($key, $value) = each %options) {
    logging("$key: $value");
    trace("$key: $value");
}
# End handle input values

# Make database connection to database protegeTable
my $connectionstring = "DBI:mysql:database=$cmdbmetaDB;host=$server";
$dbh = DBI->connect($connectionstring, $username, $password,
		   {'PrintError' => $printerror,    # Set to 1 for debug info
		    'RaiseError' => 0});	    	# Do not die on error
if (not defined $dbh) {
   	error("Could not open $cmdbmetaDB, exiting...");
   	exit_application(1);
}

# Make second database connection to database protegeTable
# my $connectionstring = "DBI:mysql:database=$databasename;host=$server";
$dbh2 = DBI->connect($connectionstring, $username, $password,
		   {'PrintError' => $printerror,    # Set to 1 for debug info
		    'RaiseError' => 0});	    	# Do not die on error
if (not defined $dbh2) {
   	error("Could not open $cmdbmetaDB, exiting...");
   	exit_application(1);
}

# Preparation 
# Create Array with all classes in strict parent-child relationship
# Update Parent-child hash (for efficiency reasons).
prepare_struct("THING");

# Now explode each (child) class attributes
while (my $class = shift @classes) {
	if (defined $parent{$class}) {
		my $cl_parent = $parent{$class};
		explode($class, $cl_parent);
		$table_count++;
	} else {
		error("Class $class has no parent defined.");
	}
}

exit_application(0);

=head1 To Do

=over 4

=item *

Allow to specify database name and table name as input variables.

=back

=head1 AUTHOR

Any suggestions or bug reports, please contact E<lt>dirk.vermeylen@eds.comE<gt>
